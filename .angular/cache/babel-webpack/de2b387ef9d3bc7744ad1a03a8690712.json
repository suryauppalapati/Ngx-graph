{"ast":null,"code":"import { Injectable, EventEmitter, Component, ViewEncapsulation, ChangeDetectionStrategy, ElementRef, NgZone, ChangeDetectorRef, Input, Output, ContentChild, ViewChild, ViewChildren, HostListener, Directive, NgModule } from '@angular/core';\nimport { __decorate, __metadata } from 'tslib';\nimport { BaseChartComponent, calculateViewDimensions, ColorHelper, ChartComponent, ChartCommonModule, NgxChartsModule } from '@swimlane/ngx-charts';\nimport { select } from 'd3-selection';\nimport { curveBundle, line } from 'd3-shape';\nimport { easeSinInOut } from 'd3-ease';\nimport 'd3-transition';\nimport { Subject, Subscription, Observable, of } from 'rxjs';\nimport { first } from 'rxjs/operators';\nimport { identity, transform, translate, scale, toSVG, smoothMatrix } from 'transformation-matrix';\nimport { layout, graphlib } from 'dagre';\nimport * as d3Force from 'd3-force';\nimport { forceSimulation, forceManyBody, forceCollide, forceLink } from 'd3-force';\nimport { d3adaptor } from 'webcola';\nimport * as d3Dispatch from 'd3-dispatch';\nimport * as d3Timer from 'd3-timer';\nimport * as ɵngcc0 from '@angular/core';\nimport * as ɵngcc1 from '@swimlane/ngx-charts';\nimport * as ɵngcc2 from '@angular/common';\nconst _c0 = [\"linkTemplate\"];\nconst _c1 = [\"nodeTemplate\"];\nconst _c2 = [\"clusterTemplate\"];\nconst _c3 = [\"defsTemplate\"];\nconst _c4 = [\"miniMapNodeTemplate\"];\nconst _c5 = [\"nodeElement\"];\nconst _c6 = [\"linkElement\"];\n\nfunction GraphComponent__svg_g_1__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainer(0, 13);\n  }\n\n  if (rf & 2) {\n    const ctx_r2 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r2.defsTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_path_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"path\", 14);\n  }\n\n  if (rf & 2) {\n    const link_r7 = ctx.$implicit;\n    ɵngcc0.ɵɵattribute(\"d\", link_r7.textPath)(\"id\", link_r7.id);\n  }\n}\n\nconst _c7 = function (a0) {\n  return {\n    $implicit: a0\n  };\n};\n\nfunction GraphComponent__svg_g_1__svg_g_7__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainer(0, 19);\n  }\n\n  if (rf & 2) {\n    const node_r8 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r10 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r10.clusterTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c7, node_r8));\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_7__svg_g_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 20);\n    ɵngcc0.ɵɵelement(1, \"rect\");\n    ɵngcc0.ɵɵelementStart(2, \"text\", 21);\n    ɵngcc0.ɵɵtext(3);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r8 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"width\", node_r8.dimension.width)(\"height\", node_r8.dimension.height)(\"fill\", node_r8.data == null ? null : node_r8.data.color);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"x\", 10)(\"y\", node_r8.dimension.height / 2);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵtextInterpolate1(\" \", node_r8.label, \" \");\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_7_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r15 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 15, 16);\n    ɵngcc0.ɵɵlistener(\"click\", function GraphComponent__svg_g_1__svg_g_7_Template__svg_g_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r15);\n      const node_r8 = restoredCtx.$implicit;\n      const ctx_r14 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r14.onClick(node_r8);\n    });\n    ɵngcc0.ɵɵtemplate(2, GraphComponent__svg_g_1__svg_g_7__svg_ng_container_2_Template, 1, 4, \"ng-container\", 17);\n    ɵngcc0.ɵɵtemplate(3, GraphComponent__svg_g_1__svg_g_7__svg_g_3_Template, 4, 6, \"g\", 18);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r8 = ctx.$implicit;\n    const ctx_r4 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"old-node\", ctx_r4.animate && ctx_r4.oldClusters.has(node_r8.id));\n    ɵngcc0.ɵɵproperty(\"id\", node_r8.id);\n    ɵngcc0.ɵɵattribute(\"transform\", node_r8.transform);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r4.clusterTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r4.clusterTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_9__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainer(0, 19);\n  }\n\n  if (rf & 2) {\n    const link_r16 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r18 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r18.linkTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c7, link_r16));\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_9__svg_path_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"path\", 25);\n  }\n\n  if (rf & 2) {\n    const link_r16 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵattribute(\"d\", link_r16.line);\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_9_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 22, 23);\n    ɵngcc0.ɵɵtemplate(2, GraphComponent__svg_g_1__svg_g_9__svg_ng_container_2_Template, 1, 4, \"ng-container\", 17);\n    ɵngcc0.ɵɵtemplate(3, GraphComponent__svg_g_1__svg_g_9__svg_path_3_Template, 1, 1, \"path\", 24);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const link_r16 = ctx.$implicit;\n    const ctx_r5 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"id\", link_r16.id);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r5.linkTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r5.linkTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_11__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainer(0, 19);\n  }\n\n  if (rf & 2) {\n    const node_r22 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r24 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r24.nodeTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c7, node_r22));\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_11__svg_circle_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"circle\", 29);\n  }\n\n  if (rf & 2) {\n    const node_r22 = ɵngcc0.ɵɵnextContext().$implicit;\n    ɵngcc0.ɵɵattribute(\"cx\", node_r22.dimension.width / 2)(\"cy\", node_r22.dimension.height / 2)(\"fill\", node_r22.data == null ? null : node_r22.data.color);\n  }\n}\n\nfunction GraphComponent__svg_g_1__svg_g_11_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r29 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 26, 27);\n    ɵngcc0.ɵɵlistener(\"click\", function GraphComponent__svg_g_1__svg_g_11_Template__svg_g_click_0_listener() {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r29);\n      const node_r22 = restoredCtx.$implicit;\n      const ctx_r28 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r28.onClick(node_r22);\n    })(\"mousedown\", function GraphComponent__svg_g_1__svg_g_11_Template__svg_g_mousedown_0_listener($event) {\n      const restoredCtx = ɵngcc0.ɵɵrestoreView(_r29);\n      const node_r22 = restoredCtx.$implicit;\n      const ctx_r30 = ɵngcc0.ɵɵnextContext(2);\n      return ctx_r30.onNodeMouseDown($event, node_r22);\n    });\n    ɵngcc0.ɵɵtemplate(2, GraphComponent__svg_g_1__svg_g_11__svg_ng_container_2_Template, 1, 4, \"ng-container\", 17);\n    ɵngcc0.ɵɵtemplate(3, GraphComponent__svg_g_1__svg_g_11__svg_circle_3_Template, 1, 3, \"circle\", 28);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r22 = ctx.$implicit;\n    const ctx_r6 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"old-node\", ctx_r6.animate && ctx_r6.oldNodes.has(node_r22.id));\n    ɵngcc0.ɵɵproperty(\"id\", node_r22.id);\n    ɵngcc0.ɵɵattribute(\"transform\", node_r22.transform);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r6.nodeTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r6.nodeTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_1_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r32 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 3);\n    ɵngcc0.ɵɵlistener(\"touchstart\", function GraphComponent__svg_g_1_Template__svg_g_touchstart_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r32);\n      const ctx_r31 = ɵngcc0.ɵɵnextContext();\n      return ctx_r31.onTouchStart($event);\n    })(\"touchend\", function GraphComponent__svg_g_1_Template__svg_g_touchend_0_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r32);\n      const ctx_r33 = ɵngcc0.ɵɵnextContext();\n      return ctx_r33.onTouchEnd($event);\n    });\n    ɵngcc0.ɵɵelementStart(1, \"defs\");\n    ɵngcc0.ɵɵtemplate(2, GraphComponent__svg_g_1__svg_ng_container_2_Template, 1, 1, \"ng-container\", 4);\n    ɵngcc0.ɵɵtemplate(3, GraphComponent__svg_g_1__svg_path_3_Template, 1, 2, \"path\", 5);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(4, \"rect\", 6);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function GraphComponent__svg_g_1_Template__svg_rect_mousedown_4_listener() {\n      ɵngcc0.ɵɵrestoreView(_r32);\n      const ctx_r34 = ɵngcc0.ɵɵnextContext();\n      return ctx_r34.isPanning = true;\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵprojection(5);\n    ɵngcc0.ɵɵelementStart(6, \"g\", 7);\n    ɵngcc0.ɵɵtemplate(7, GraphComponent__svg_g_1__svg_g_7_Template, 4, 6, \"g\", 8);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(8, \"g\", 9);\n    ɵngcc0.ɵɵtemplate(9, GraphComponent__svg_g_1__svg_g_9_Template, 4, 3, \"g\", 10);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(10, \"g\", 11);\n    ɵngcc0.ɵɵtemplate(11, GraphComponent__svg_g_1__svg_g_11_Template, 4, 6, \"g\", 12);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r0 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"transform\", ctx_r0.transform);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r0.defsTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.edges);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"width\", ctx_r0.dims.width * 100)(\"height\", ctx_r0.dims.height * 100)(\"transform\", \"translate(\" + (-ctx_r0.dims.width || 0) * 50 + \",\" + (-ctx_r0.dims.height || 0) * 50 + \")\");\n    ɵngcc0.ɵɵadvance(3);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.clusters)(\"ngForTrackBy\", ctx_r0.trackNodeBy);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.edges)(\"ngForTrackBy\", ctx_r0.trackLinkBy);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r0.graph.nodes)(\"ngForTrackBy\", ctx_r0.trackNodeBy);\n  }\n}\n\nfunction GraphComponent__svg_g_4__svg_g_4__svg_ng_container_2_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainer(0, 19);\n  }\n\n  if (rf & 2) {\n    const node_r36 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r38 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r38.miniMapNodeTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c7, node_r36));\n  }\n}\n\nfunction GraphComponent__svg_g_4__svg_g_4__svg_ng_container_3_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementContainer(0, 19);\n  }\n\n  if (rf & 2) {\n    const node_r36 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r39 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵproperty(\"ngTemplateOutlet\", ctx_r39.nodeTemplate)(\"ngTemplateOutletContext\", ɵngcc0.ɵɵpureFunction1(2, _c7, node_r36));\n  }\n}\n\nfunction GraphComponent__svg_g_4__svg_g_4__svg_circle_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelement(0, \"circle\", 29);\n  }\n\n  if (rf & 2) {\n    const node_r36 = ɵngcc0.ɵɵnextContext().$implicit;\n    const ctx_r40 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵattribute(\"cx\", node_r36.dimension.width / 2 / ctx_r40.minimapScaleCoefficient)(\"cy\", node_r36.dimension.height / 2 / ctx_r40.minimapScaleCoefficient)(\"fill\", node_r36.data == null ? null : node_r36.data.color);\n  }\n}\n\nfunction GraphComponent__svg_g_4__svg_g_4_Template(rf, ctx) {\n  if (rf & 1) {\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 35, 27);\n    ɵngcc0.ɵɵtemplate(2, GraphComponent__svg_g_4__svg_g_4__svg_ng_container_2_Template, 1, 4, \"ng-container\", 17);\n    ɵngcc0.ɵɵtemplate(3, GraphComponent__svg_g_4__svg_g_4__svg_ng_container_3_Template, 1, 4, \"ng-container\", 17);\n    ɵngcc0.ɵɵtemplate(4, GraphComponent__svg_g_4__svg_g_4__svg_circle_4_Template, 1, 3, \"circle\", 28);\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const node_r36 = ctx.$implicit;\n    const ctx_r35 = ɵngcc0.ɵɵnextContext(2);\n    ɵngcc0.ɵɵclassProp(\"old-node\", ctx_r35.animate && ctx_r35.oldNodes.has(node_r36.id));\n    ɵngcc0.ɵɵproperty(\"id\", node_r36.id);\n    ɵngcc0.ɵɵattribute(\"transform\", node_r36.transform);\n    ɵngcc0.ɵɵadvance(2);\n    ɵngcc0.ɵɵproperty(\"ngIf\", ctx_r35.miniMapNodeTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r35.miniMapNodeTemplate && ctx_r35.nodeTemplate);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngIf\", !ctx_r35.nodeTemplate && !ctx_r35.miniMapNodeTemplate);\n  }\n}\n\nfunction GraphComponent__svg_g_4_Template(rf, ctx) {\n  if (rf & 1) {\n    const _r45 = ɵngcc0.ɵɵgetCurrentView();\n\n    ɵngcc0.ɵɵnamespaceSVG();\n    ɵngcc0.ɵɵelementStart(0, \"g\", 30);\n    ɵngcc0.ɵɵelementStart(1, \"rect\", 31);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function GraphComponent__svg_g_4_Template__svg_rect_mousedown_1_listener($event) {\n      ɵngcc0.ɵɵrestoreView(_r45);\n      const ctx_r44 = ɵngcc0.ɵɵnextContext();\n      return ctx_r44.onMinimapPanTo($event);\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(2, \"g\");\n    ɵngcc0.ɵɵelementStart(3, \"g\", 32);\n    ɵngcc0.ɵɵtemplate(4, GraphComponent__svg_g_4__svg_g_4_Template, 5, 7, \"g\", 33);\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementStart(5, \"rect\", 34);\n    ɵngcc0.ɵɵlistener(\"mousedown\", function GraphComponent__svg_g_4_Template__svg_rect_mousedown_5_listener() {\n      ɵngcc0.ɵɵrestoreView(_r45);\n      const ctx_r46 = ɵngcc0.ɵɵnextContext();\n      return ctx_r46.onMinimapDragMouseDown();\n    });\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n    ɵngcc0.ɵɵelementEnd();\n  }\n\n  if (rf & 2) {\n    const ctx_r1 = ɵngcc0.ɵɵnextContext();\n    ɵngcc0.ɵɵattribute(\"transform\", ctx_r1.minimapTransform)(\"clip-path\", \"url(#\" + ctx_r1.minimapClipPathId + \")\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵattribute(\"width\", ctx_r1.graphDims.width / ctx_r1.minimapScaleCoefficient)(\"height\", ctx_r1.graphDims.height / ctx_r1.minimapScaleCoefficient);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"transform\", \"translate(\" + -ctx_r1.minimapOffsetX / ctx_r1.minimapScaleCoefficient + \"px,\" + -ctx_r1.minimapOffsetY / ctx_r1.minimapScaleCoefficient + \"px)\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵstyleProp(\"transform\", \"scale(\" + 1 / ctx_r1.minimapScaleCoefficient + \")\");\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵproperty(\"ngForOf\", ctx_r1.graph.nodes)(\"ngForTrackBy\", ctx_r1.trackNodeBy);\n    ɵngcc0.ɵɵadvance(1);\n    ɵngcc0.ɵɵclassProp(\"panning\", ctx_r1.isMinimapPanning);\n    ɵngcc0.ɵɵattribute(\"transform\", \"translate(\" + ctx_r1.panOffsetX / ctx_r1.zoomLevel / -ctx_r1.minimapScaleCoefficient + \",\" + ctx_r1.panOffsetY / ctx_r1.zoomLevel / -ctx_r1.minimapScaleCoefficient + \")\")(\"width\", ctx_r1.width / ctx_r1.minimapScaleCoefficient / ctx_r1.zoomLevel)(\"height\", ctx_r1.height / ctx_r1.minimapScaleCoefficient / ctx_r1.zoomLevel);\n  }\n}\n\nconst _c8 = function (a0, a1) {\n  return [a0, a1];\n};\n\nconst _c9 = [\"*\"];\nconst cache = {};\n/**\n * Generates a short id.\n *\n */\n\nfunction id() {\n  let newId = ('0000' + (Math.random() * Math.pow(36, 4) << 0).toString(36)).slice(-4);\n  newId = `a${newId}`; // ensure not already used\n\n  if (!cache[newId]) {\n    cache[newId] = true;\n    return newId;\n  }\n\n  return id();\n}\n\nvar Orientation = /*#__PURE__*/(() => {\n  (function (Orientation) {\n    Orientation[\"LEFT_TO_RIGHT\"] = \"LR\";\n    Orientation[\"RIGHT_TO_LEFT\"] = \"RL\";\n    Orientation[\"TOP_TO_BOTTOM\"] = \"TB\";\n    Orientation[\"BOTTOM_TO_TOM\"] = \"BT\";\n  })(Orientation || (Orientation = {}));\n\n  return Orientation;\n})();\nvar Alignment = /*#__PURE__*/(() => {\n  (function (Alignment) {\n    Alignment[\"CENTER\"] = \"C\";\n    Alignment[\"UP_LEFT\"] = \"UL\";\n    Alignment[\"UP_RIGHT\"] = \"UR\";\n    Alignment[\"DOWN_LEFT\"] = \"DL\";\n    Alignment[\"DOWN_RIGHT\"] = \"DR\";\n  })(Alignment || (Alignment = {}));\n\n  return Alignment;\n})();\n\nclass DagreLayout {\n  constructor() {\n    this.defaultSettings = {\n      orientation: Orientation.LEFT_TO_RIGHT,\n      marginX: 20,\n      marginY: 20,\n      edgePadding: 100,\n      rankPadding: 100,\n      nodePadding: 50,\n      multigraph: true,\n      compound: true\n    };\n    this.settings = {};\n  }\n\n  run(graph) {\n    this.createDagreGraph(graph);\n    layout(this.dagreGraph);\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    for (const dagreNodeId in this.dagreGraph._nodes) {\n      const dagreNode = this.dagreGraph._nodes[dagreNodeId];\n      const node = graph.nodes.find(n => n.id === dagreNode.id);\n      node.position = {\n        x: dagreNode.x,\n        y: dagreNode.y\n      };\n      node.dimension = {\n        width: dagreNode.width,\n        height: dagreNode.height\n      };\n    }\n\n    return graph;\n  }\n\n  updateEdge(graph, edge) {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target); // determine new arrow position\n\n    const dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;\n    const startingPoint = {\n      x: sourceNode.position.x,\n      y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)\n    };\n    const endingPoint = {\n      x: targetNode.position.x,\n      y: targetNode.position.y + dir * (targetNode.dimension.height / 2)\n    }; // generate new points\n\n    edge.points = [startingPoint, endingPoint];\n    return graph;\n  }\n\n  createDagreGraph(graph) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new graphlib.Graph({\n      compound: settings.compound,\n      multigraph: settings.multigraph\n    });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    }); // Default to assigning a new object as a label for each new edge.\n\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n    this.dagreNodes = graph.nodes.map(n => {\n      const node = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink = Object.assign({}, l);\n\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      if (!node.width) {\n        node.width = 20;\n      }\n\n      if (!node.height) {\n        node.height = 30;\n      } // update dagre\n\n\n      this.dagreGraph.setNode(node.id, node);\n    } // update dagre\n\n\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n\n}\n\nclass DagreClusterLayout {\n  constructor() {\n    this.defaultSettings = {\n      orientation: Orientation.LEFT_TO_RIGHT,\n      marginX: 20,\n      marginY: 20,\n      edgePadding: 100,\n      rankPadding: 100,\n      nodePadding: 50,\n      multigraph: true,\n      compound: true\n    };\n    this.settings = {};\n  }\n\n  run(graph) {\n    this.createDagreGraph(graph);\n    layout(this.dagreGraph);\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    const dagreToOutput = node => {\n      const dagreNode = this.dagreGraph._nodes[node.id];\n      return Object.assign(Object.assign({}, node), {\n        position: {\n          x: dagreNode.x,\n          y: dagreNode.y\n        },\n        dimension: {\n          width: dagreNode.width,\n          height: dagreNode.height\n        }\n      });\n    };\n\n    graph.clusters = (graph.clusters || []).map(dagreToOutput);\n    graph.nodes = graph.nodes.map(dagreToOutput);\n    return graph;\n  }\n\n  updateEdge(graph, edge) {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target); // determine new arrow position\n\n    const dir = sourceNode.position.y <= targetNode.position.y ? -1 : 1;\n    const startingPoint = {\n      x: sourceNode.position.x,\n      y: sourceNode.position.y - dir * (sourceNode.dimension.height / 2)\n    };\n    const endingPoint = {\n      x: targetNode.position.x,\n      y: targetNode.position.y + dir * (targetNode.dimension.height / 2)\n    }; // generate new points\n\n    edge.points = [startingPoint, endingPoint];\n    return graph;\n  }\n\n  createDagreGraph(graph) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new graphlib.Graph({\n      compound: settings.compound,\n      multigraph: settings.multigraph\n    });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    }); // Default to assigning a new object as a label for each new edge.\n\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n    this.dagreNodes = graph.nodes.map(n => {\n      const node = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n    this.dagreClusters = graph.clusters || [];\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink = Object.assign({}, l);\n\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      this.dagreGraph.setNode(node.id, node);\n    }\n\n    for (const cluster of this.dagreClusters) {\n      this.dagreGraph.setNode(cluster.id, cluster);\n      cluster.childNodeIds.forEach(childNodeId => {\n        this.dagreGraph.setParent(childNodeId, cluster.id);\n      });\n    } // update dagre\n\n\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n\n}\n\nconst DEFAULT_EDGE_NAME = '\\x00';\nconst GRAPH_NODE = '\\x00';\nconst EDGE_KEY_DELIM = '\\x01';\n\nclass DagreNodesOnlyLayout {\n  constructor() {\n    this.defaultSettings = {\n      orientation: Orientation.LEFT_TO_RIGHT,\n      marginX: 20,\n      marginY: 20,\n      edgePadding: 100,\n      rankPadding: 100,\n      nodePadding: 50,\n      curveDistance: 20,\n      multigraph: true,\n      compound: true\n    };\n    this.settings = {};\n  }\n\n  run(graph) {\n    this.createDagreGraph(graph);\n    layout(this.dagreGraph);\n    graph.edgeLabels = this.dagreGraph._edgeLabels;\n\n    for (const dagreNodeId in this.dagreGraph._nodes) {\n      const dagreNode = this.dagreGraph._nodes[dagreNodeId];\n      const node = graph.nodes.find(n => n.id === dagreNode.id);\n      node.position = {\n        x: dagreNode.x,\n        y: dagreNode.y\n      };\n      node.dimension = {\n        width: dagreNode.width,\n        height: dagreNode.height\n      };\n    }\n\n    for (const edge of graph.edges) {\n      this.updateEdge(graph, edge);\n    }\n\n    return graph;\n  }\n\n  updateEdge(graph, edge) {\n    const sourceNode = graph.nodes.find(n => n.id === edge.source);\n    const targetNode = graph.nodes.find(n => n.id === edge.target);\n    const rankAxis = this.settings.orientation === 'BT' || this.settings.orientation === 'TB' ? 'y' : 'x';\n    const orderAxis = rankAxis === 'y' ? 'x' : 'y';\n    const rankDimension = rankAxis === 'y' ? 'height' : 'width'; // determine new arrow position\n\n    const dir = sourceNode.position[rankAxis] <= targetNode.position[rankAxis] ? -1 : 1;\n    const startingPoint = {\n      [orderAxis]: sourceNode.position[orderAxis],\n      [rankAxis]: sourceNode.position[rankAxis] - dir * (sourceNode.dimension[rankDimension] / 2)\n    };\n    const endingPoint = {\n      [orderAxis]: targetNode.position[orderAxis],\n      [rankAxis]: targetNode.position[rankAxis] + dir * (targetNode.dimension[rankDimension] / 2)\n    };\n    const curveDistance = this.settings.curveDistance || this.defaultSettings.curveDistance; // generate new points\n\n    edge.points = [startingPoint, {\n      [orderAxis]: startingPoint[orderAxis],\n      [rankAxis]: startingPoint[rankAxis] - dir * curveDistance\n    }, {\n      [orderAxis]: endingPoint[orderAxis],\n      [rankAxis]: endingPoint[rankAxis] + dir * curveDistance\n    }, endingPoint];\n    const edgeLabelId = `${edge.source}${EDGE_KEY_DELIM}${edge.target}${EDGE_KEY_DELIM}${DEFAULT_EDGE_NAME}`;\n    const matchingEdgeLabel = graph.edgeLabels[edgeLabelId];\n\n    if (matchingEdgeLabel) {\n      matchingEdgeLabel.points = edge.points;\n    }\n\n    return graph;\n  }\n\n  createDagreGraph(graph) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n    this.dagreGraph = new graphlib.Graph({\n      compound: settings.compound,\n      multigraph: settings.multigraph\n    });\n    this.dagreGraph.setGraph({\n      rankdir: settings.orientation,\n      marginx: settings.marginX,\n      marginy: settings.marginY,\n      edgesep: settings.edgePadding,\n      ranksep: settings.rankPadding,\n      nodesep: settings.nodePadding,\n      align: settings.align,\n      acyclicer: settings.acyclicer,\n      ranker: settings.ranker,\n      multigraph: settings.multigraph,\n      compound: settings.compound\n    }); // Default to assigning a new object as a label for each new edge.\n\n    this.dagreGraph.setDefaultEdgeLabel(() => {\n      return {\n        /* empty */\n      };\n    });\n    this.dagreNodes = graph.nodes.map(n => {\n      const node = Object.assign({}, n);\n      node.width = n.dimension.width;\n      node.height = n.dimension.height;\n      node.x = n.position.x;\n      node.y = n.position.y;\n      return node;\n    });\n    this.dagreEdges = graph.edges.map(l => {\n      const newLink = Object.assign({}, l);\n\n      if (!newLink.id) {\n        newLink.id = id();\n      }\n\n      return newLink;\n    });\n\n    for (const node of this.dagreNodes) {\n      if (!node.width) {\n        node.width = 20;\n      }\n\n      if (!node.height) {\n        node.height = 30;\n      } // update dagre\n\n\n      this.dagreGraph.setNode(node.id, node);\n    } // update dagre\n\n\n    for (const edge of this.dagreEdges) {\n      if (settings.multigraph) {\n        this.dagreGraph.setEdge(edge.source, edge.target, edge, edge.id);\n      } else {\n        this.dagreGraph.setEdge(edge.source, edge.target);\n      }\n    }\n\n    return this.dagreGraph;\n  }\n\n}\n\nfunction toD3Node(maybeNode) {\n  if (typeof maybeNode === 'string') {\n    return {\n      id: maybeNode,\n      x: 0,\n      y: 0\n    };\n  }\n\n  return maybeNode;\n}\n\nclass D3ForceDirectedLayout {\n  constructor() {\n    this.defaultSettings = {\n      force: forceSimulation().force('charge', forceManyBody().strength(-150)).force('collide', forceCollide(5)),\n      forceLink: forceLink().id(node => node.id).distance(() => 100)\n    };\n    this.settings = {};\n    this.outputGraph$ = new Subject();\n  }\n\n  run(graph) {\n    this.inputGraph = graph;\n    this.d3Graph = {\n      nodes: [...this.inputGraph.nodes.map(n => Object.assign({}, n))],\n      edges: [...this.inputGraph.edges.map(e => Object.assign({}, e))]\n    };\n    this.outputGraph = {\n      nodes: [],\n      edges: [],\n      edgeLabels: []\n    };\n    this.outputGraph$.next(this.outputGraph);\n    this.settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (this.settings.force) {\n      this.settings.force.nodes(this.d3Graph.nodes).force('link', this.settings.forceLink.links(this.d3Graph.edges)).alpha(0.5).restart().on('tick', () => {\n        this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph));\n      });\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  updateEdge(graph, edge) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (settings.force) {\n      settings.force.nodes(this.d3Graph.nodes).force('link', settings.forceLink.links(this.d3Graph.edges)).alpha(0.5).restart().on('tick', () => {\n        this.outputGraph$.next(this.d3GraphToOutputGraph(this.d3Graph));\n      });\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  d3GraphToOutputGraph(d3Graph) {\n    this.outputGraph.nodes = this.d3Graph.nodes.map(node => Object.assign(Object.assign({}, node), {\n      id: node.id || id(),\n      position: {\n        x: node.x,\n        y: node.y\n      },\n      dimension: {\n        width: node.dimension && node.dimension.width || 20,\n        height: node.dimension && node.dimension.height || 20\n      },\n      transform: `translate(${node.x - (node.dimension && node.dimension.width || 20) / 2 || 0}, ${node.y - (node.dimension && node.dimension.height || 20) / 2 || 0})`\n    }));\n    this.outputGraph.edges = this.d3Graph.edges.map(edge => Object.assign(Object.assign({}, edge), {\n      source: toD3Node(edge.source).id,\n      target: toD3Node(edge.target).id,\n      points: [{\n        x: toD3Node(edge.source).x,\n        y: toD3Node(edge.source).y\n      }, {\n        x: toD3Node(edge.target).x,\n        y: toD3Node(edge.target).y\n      }]\n    }));\n    this.outputGraph.edgeLabels = this.outputGraph.edges;\n    return this.outputGraph;\n  }\n\n  onDragStart(draggingNode, $event) {\n    this.settings.force.alphaTarget(0.3).restart();\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n\n    if (!node) {\n      return;\n    }\n\n    this.draggingStart = {\n      x: $event.x - node.x,\n      y: $event.y - node.y\n    };\n    node.fx = $event.x - this.draggingStart.x;\n    node.fy = $event.y - this.draggingStart.y;\n  }\n\n  onDrag(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n\n    if (!node) {\n      return;\n    }\n\n    node.fx = $event.x - this.draggingStart.x;\n    node.fy = $event.y - this.draggingStart.y;\n  }\n\n  onDragEnd(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const node = this.d3Graph.nodes.find(d3Node => d3Node.id === draggingNode.id);\n\n    if (!node) {\n      return;\n    }\n\n    this.settings.force.alphaTarget(0);\n    node.fx = undefined;\n    node.fy = undefined;\n  }\n\n}\n\nfunction toNode(nodes, nodeRef) {\n  if (typeof nodeRef === 'number') {\n    return nodes[nodeRef];\n  }\n\n  return nodeRef;\n}\n\nclass ColaForceDirectedLayout {\n  constructor() {\n    this.defaultSettings = {\n      force: d3adaptor(Object.assign(Object.assign(Object.assign({}, d3Dispatch), d3Force), d3Timer)).linkDistance(150).avoidOverlaps(true),\n      viewDimensions: {\n        width: 600,\n        height: 600,\n        xOffset: 0\n      }\n    };\n    this.settings = {};\n    this.outputGraph$ = new Subject();\n  }\n\n  run(graph) {\n    this.inputGraph = graph;\n\n    if (!this.inputGraph.clusters) {\n      this.inputGraph.clusters = [];\n    }\n\n    this.internalGraph = {\n      nodes: [...this.inputGraph.nodes.map(n => Object.assign(Object.assign({}, n), {\n        width: n.dimension ? n.dimension.width : 20,\n        height: n.dimension ? n.dimension.height : 20\n      }))],\n      groups: [...this.inputGraph.clusters.map(cluster => ({\n        padding: 5,\n        groups: cluster.childNodeIds.map(nodeId => this.inputGraph.clusters.findIndex(node => node.id === nodeId)).filter(x => x >= 0),\n        leaves: cluster.childNodeIds.map(nodeId => this.inputGraph.nodes.findIndex(node => node.id === nodeId)).filter(x => x >= 0)\n      }))],\n      links: [...this.inputGraph.edges.map(e => {\n        const sourceNodeIndex = this.inputGraph.nodes.findIndex(node => e.source === node.id);\n        const targetNodeIndex = this.inputGraph.nodes.findIndex(node => e.target === node.id);\n\n        if (sourceNodeIndex === -1 || targetNodeIndex === -1) {\n          return undefined;\n        }\n\n        return Object.assign(Object.assign({}, e), {\n          source: sourceNodeIndex,\n          target: targetNodeIndex\n        });\n      }).filter(x => !!x)],\n      groupLinks: [...this.inputGraph.edges.map(e => {\n        const sourceNodeIndex = this.inputGraph.nodes.findIndex(node => e.source === node.id);\n        const targetNodeIndex = this.inputGraph.nodes.findIndex(node => e.target === node.id);\n\n        if (sourceNodeIndex >= 0 && targetNodeIndex >= 0) {\n          return undefined;\n        }\n\n        return e;\n      }).filter(x => !!x)]\n    };\n    this.outputGraph = {\n      nodes: [],\n      clusters: [],\n      edges: [],\n      edgeLabels: []\n    };\n    this.outputGraph$.next(this.outputGraph);\n    this.settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (this.settings.force) {\n      this.settings.force = this.settings.force.nodes(this.internalGraph.nodes).groups(this.internalGraph.groups).links(this.internalGraph.links).alpha(0.5).on('tick', () => {\n        if (this.settings.onTickListener) {\n          this.settings.onTickListener(this.internalGraph);\n        }\n\n        this.outputGraph$.next(this.internalGraphToOutputGraph(this.internalGraph));\n      });\n\n      if (this.settings.viewDimensions) {\n        this.settings.force = this.settings.force.size([this.settings.viewDimensions.width, this.settings.viewDimensions.height]);\n      }\n\n      if (this.settings.forceModifierFn) {\n        this.settings.force = this.settings.forceModifierFn(this.settings.force);\n      }\n\n      this.settings.force.start();\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  updateEdge(graph, edge) {\n    const settings = Object.assign({}, this.defaultSettings, this.settings);\n\n    if (settings.force) {\n      settings.force.start();\n    }\n\n    return this.outputGraph$.asObservable();\n  }\n\n  internalGraphToOutputGraph(internalGraph) {\n    this.outputGraph.nodes = internalGraph.nodes.map(node => Object.assign(Object.assign({}, node), {\n      id: node.id || id(),\n      position: {\n        x: node.x,\n        y: node.y\n      },\n      dimension: {\n        width: node.dimension && node.dimension.width || 20,\n        height: node.dimension && node.dimension.height || 20\n      },\n      transform: `translate(${node.x - (node.dimension && node.dimension.width || 20) / 2 || 0}, ${node.y - (node.dimension && node.dimension.height || 20) / 2 || 0})`\n    }));\n    this.outputGraph.edges = internalGraph.links.map(edge => {\n      const source = toNode(internalGraph.nodes, edge.source);\n      const target = toNode(internalGraph.nodes, edge.target);\n      return Object.assign(Object.assign({}, edge), {\n        source: source.id,\n        target: target.id,\n        points: [source.bounds.rayIntersection(target.bounds.cx(), target.bounds.cy()), target.bounds.rayIntersection(source.bounds.cx(), source.bounds.cy())]\n      });\n    }).concat(internalGraph.groupLinks.map(groupLink => {\n      const sourceNode = internalGraph.nodes.find(foundNode => foundNode.id === groupLink.source);\n      const targetNode = internalGraph.nodes.find(foundNode => foundNode.id === groupLink.target);\n      const source = sourceNode || internalGraph.groups.find(foundGroup => foundGroup.id === groupLink.source);\n      const target = targetNode || internalGraph.groups.find(foundGroup => foundGroup.id === groupLink.target);\n      return Object.assign(Object.assign({}, groupLink), {\n        source: source.id,\n        target: target.id,\n        points: [source.bounds.rayIntersection(target.bounds.cx(), target.bounds.cy()), target.bounds.rayIntersection(source.bounds.cx(), source.bounds.cy())]\n      });\n    }));\n    this.outputGraph.clusters = internalGraph.groups.map((group, index) => {\n      const inputGroup = this.inputGraph.clusters[index];\n      return Object.assign(Object.assign({}, inputGroup), {\n        dimension: {\n          width: group.bounds ? group.bounds.width() : 20,\n          height: group.bounds ? group.bounds.height() : 20\n        },\n        position: {\n          x: group.bounds ? group.bounds.x + group.bounds.width() / 2 : 0,\n          y: group.bounds ? group.bounds.y + group.bounds.height() / 2 : 0\n        }\n      });\n    });\n    this.outputGraph.edgeLabels = this.outputGraph.edges;\n    return this.outputGraph;\n  }\n\n  onDragStart(draggingNode, $event) {\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n\n    if (!node) {\n      return;\n    }\n\n    this.draggingStart = {\n      x: node.x - $event.x,\n      y: node.y - $event.y\n    };\n    node.fixed = 1;\n    this.settings.force.start();\n  }\n\n  onDrag(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n\n    if (!node) {\n      return;\n    }\n\n    node.x = this.draggingStart.x + $event.x;\n    node.y = this.draggingStart.y + $event.y;\n  }\n\n  onDragEnd(draggingNode, $event) {\n    if (!draggingNode) {\n      return;\n    }\n\n    const nodeIndex = this.outputGraph.nodes.findIndex(foundNode => foundNode.id === draggingNode.id);\n    const node = this.internalGraph.nodes[nodeIndex];\n\n    if (!node) {\n      return;\n    }\n\n    node.fixed = 0;\n  }\n\n}\n\nconst layouts = {\n  dagre: DagreLayout,\n  dagreCluster: DagreClusterLayout,\n  dagreNodesOnly: DagreNodesOnlyLayout,\n  d3ForceDirected: D3ForceDirectedLayout,\n  colaForceDirected: ColaForceDirectedLayout\n};\nlet LayoutService = /*#__PURE__*/(() => {\n  class LayoutService {\n    getLayout(name) {\n      if (layouts[name]) {\n        return new layouts[name]();\n      } else {\n        throw new Error(`Unknown layout type '${name}'`);\n      }\n    }\n\n  }\n\n  LayoutService.ɵfac = function LayoutService_Factory(t) {\n    return new (t || LayoutService)();\n  };\n\n  LayoutService.ɵprov = /*@__PURE__*/ɵngcc0.ɵɵdefineInjectable({\n    token: LayoutService,\n    factory: LayoutService.ɵfac\n  });\n  return LayoutService;\n})();\nvar PanningAxis = /*#__PURE__*/(() => {\n  (function (PanningAxis) {\n    PanningAxis[\"Both\"] = \"both\";\n    PanningAxis[\"Horizontal\"] = \"horizontal\";\n    PanningAxis[\"Vertical\"] = \"vertical\";\n  })(PanningAxis || (PanningAxis = {}));\n\n  return PanningAxis;\n})();\nvar MiniMapPosition = /*#__PURE__*/(() => {\n  (function (MiniMapPosition) {\n    MiniMapPosition[\"UpperLeft\"] = \"UpperLeft\";\n    MiniMapPosition[\"UpperRight\"] = \"UpperRight\";\n  })(MiniMapPosition || (MiniMapPosition = {}));\n\n  return MiniMapPosition;\n})();\n\n/**\n * Throttle a function\n *\n * @export\n * @param {*}      func\n * @param {number} wait\n * @param {*}      [options]\n * @returns\n */\nfunction throttle(func, wait, options) {\n  options = options || {};\n  let context;\n  let args;\n  let result;\n  let timeout = null;\n  let previous = 0;\n\n  function later() {\n    previous = options.leading === false ? 0 : +new Date();\n    timeout = null;\n    result = func.apply(context, args);\n  }\n\n  return function () {\n    const now = +new Date();\n\n    if (!previous && options.leading === false) {\n      previous = now;\n    }\n\n    const remaining = wait - (now - previous);\n    context = this;\n    args = arguments;\n\n    if (remaining <= 0) {\n      clearTimeout(timeout);\n      timeout = null;\n      previous = now;\n      result = func.apply(context, args);\n    } else if (!timeout && options.trailing !== false) {\n      timeout = setTimeout(later, remaining);\n    }\n\n    return result;\n  };\n}\n/**\n * Throttle decorator\n *\n *  class MyClass {\n *    throttleable(10)\n *    myFn() { ... }\n *  }\n *\n * @export\n * @param {number} duration\n * @param {*} [options]\n * @returns\n */\n\n\nfunction throttleable(duration, options) {\n  return function innerDecorator(target, key, descriptor) {\n    return {\n      configurable: true,\n      enumerable: descriptor.enumerable,\n      get: function getter() {\n        Object.defineProperty(this, key, {\n          configurable: true,\n          enumerable: descriptor.enumerable,\n          value: throttle(descriptor.value, duration, options)\n        });\n        return this[key];\n      }\n    };\n  };\n}\n\nlet GraphComponent = /*#__PURE__*/(() => {\n  class GraphComponent extends BaseChartComponent {\n    constructor(el, zone, cd, layoutService) {\n      super(el, zone, cd);\n      this.el = el;\n      this.zone = zone;\n      this.cd = cd;\n      this.layoutService = layoutService;\n      this.legend = false;\n      this.nodes = [];\n      this.clusters = [];\n      this.links = [];\n      this.activeEntries = [];\n      this.draggingEnabled = true;\n      this.panningEnabled = true;\n      this.panningAxis = PanningAxis.Both;\n      this.enableZoom = true;\n      this.zoomSpeed = 0.1;\n      this.minZoomLevel = 0.1;\n      this.maxZoomLevel = 4.0;\n      this.autoZoom = false;\n      this.panOnZoom = true;\n      this.animate = false;\n      this.autoCenter = false;\n      this.enableTrackpadSupport = false;\n      this.showMiniMap = false;\n      this.miniMapMaxWidth = 100;\n      this.miniMapPosition = MiniMapPosition.UpperRight;\n      this.activate = new EventEmitter();\n      this.deactivate = new EventEmitter();\n      this.zoomChange = new EventEmitter();\n      this.clickHandler = new EventEmitter();\n      this.isMouseMoveCalled = false;\n      this.graphSubscription = new Subscription();\n      this.subscriptions = [];\n      this.margin = [0, 0, 0, 0];\n      this.results = [];\n      this.isPanning = false;\n      this.isDragging = false;\n      this.initialized = false;\n      this.graphDims = {\n        width: 0,\n        height: 0\n      };\n      this._oldLinks = [];\n      this.oldNodes = new Set();\n      this.oldClusters = new Set();\n      this.transformationMatrix = identity();\n      this._touchLastX = null;\n      this._touchLastY = null;\n      this.minimapScaleCoefficient = 3;\n      this.minimapOffsetX = 0;\n      this.minimapOffsetY = 0;\n      this.isMinimapPanning = false;\n\n      this.groupResultsBy = node => node.label;\n    }\n    /**\n     * Get the current zoom level\n     */\n\n\n    get zoomLevel() {\n      return this.transformationMatrix.a;\n    }\n    /**\n     * Set the current zoom level\n     */\n\n\n    set zoomLevel(level) {\n      this.zoomTo(Number(level));\n    }\n    /**\n     * Get the current `x` position of the graph\n     */\n\n\n    get panOffsetX() {\n      return this.transformationMatrix.e;\n    }\n    /**\n     * Set the current `x` position of the graph\n     */\n\n\n    set panOffsetX(x) {\n      this.panTo(Number(x), null);\n    }\n    /**\n     * Get the current `y` position of the graph\n     */\n\n\n    get panOffsetY() {\n      return this.transformationMatrix.f;\n    }\n    /**\n     * Set the current `y` position of the graph\n     */\n\n\n    set panOffsetY(y) {\n      this.panTo(null, Number(y));\n    }\n    /**\n     * Angular lifecycle event\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    ngOnInit() {\n      if (this.update$) {\n        this.subscriptions.push(this.update$.subscribe(() => {\n          this.update();\n        }));\n      }\n\n      if (this.center$) {\n        this.subscriptions.push(this.center$.subscribe(() => {\n          this.center();\n        }));\n      }\n\n      if (this.zoomToFit$) {\n        this.subscriptions.push(this.zoomToFit$.subscribe(() => {\n          this.zoomToFit();\n        }));\n      }\n\n      if (this.panToNode$) {\n        this.subscriptions.push(this.panToNode$.subscribe(nodeId => {\n          this.panToNodeId(nodeId);\n        }));\n      }\n\n      this.minimapClipPathId = `minimapClip${id()}`;\n    }\n\n    ngOnChanges(changes) {\n      const {\n        layout,\n        layoutSettings,\n        nodes,\n        clusters,\n        links\n      } = changes;\n      this.setLayout(this.layout);\n\n      if (layoutSettings) {\n        this.setLayoutSettings(this.layoutSettings);\n      }\n\n      this.update();\n    }\n\n    setLayout(layout) {\n      this.initialized = false;\n\n      if (!layout) {\n        layout = 'dagre';\n      }\n\n      if (typeof layout === 'string') {\n        this.layout = this.layoutService.getLayout(layout);\n        this.setLayoutSettings(this.layoutSettings);\n      }\n    }\n\n    setLayoutSettings(settings) {\n      if (this.layout && typeof this.layout !== 'string') {\n        this.layout.settings = settings;\n      }\n    }\n    /**\n     * Angular lifecycle event\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    ngOnDestroy() {\n      super.ngOnDestroy();\n\n      for (const sub of this.subscriptions) {\n        sub.unsubscribe();\n      }\n\n      this.subscriptions = null;\n    }\n    /**\n     * Angular lifecycle event\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    ngAfterViewInit() {\n      super.ngAfterViewInit();\n      setTimeout(() => this.update());\n    }\n    /**\n     * Base class update implementation for the dag graph\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    update() {\n      super.update();\n\n      if (!this.curve) {\n        this.curve = curveBundle.beta(1);\n      }\n\n      this.zone.run(() => {\n        this.dims = calculateViewDimensions({\n          width: this.width,\n          height: this.height,\n          margins: this.margin,\n          showLegend: this.legend\n        });\n        this.seriesDomain = this.getSeriesDomain();\n        this.setColors();\n        this.legendOptions = this.getLegendOptions();\n        this.createGraph();\n        this.updateTransform();\n        this.initialized = true;\n      });\n    }\n    /**\n     * Creates the dagre graph engine\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    createGraph() {\n      this.graphSubscription.unsubscribe();\n      this.graphSubscription = new Subscription();\n\n      const initializeNode = n => {\n        if (!n.meta) {\n          n.meta = {};\n        }\n\n        if (!n.id) {\n          n.id = id();\n        }\n\n        if (!n.dimension) {\n          n.dimension = {\n            width: this.nodeWidth ? this.nodeWidth : 30,\n            height: this.nodeHeight ? this.nodeHeight : 30\n          };\n          n.meta.forceDimensions = false;\n        } else {\n          n.meta.forceDimensions = n.meta.forceDimensions === undefined ? true : n.meta.forceDimensions;\n        }\n\n        n.position = {\n          x: 0,\n          y: 0\n        };\n        n.data = n.data ? n.data : {};\n        return n;\n      };\n\n      this.graph = {\n        nodes: this.nodes.length > 0 ? [...this.nodes].map(initializeNode) : [],\n        clusters: this.clusters && this.clusters.length > 0 ? [...this.clusters].map(initializeNode) : [],\n        edges: this.links.length > 0 ? [...this.links].map(e => {\n          if (!e.id) {\n            e.id = id();\n          }\n\n          return e;\n        }) : []\n      };\n      requestAnimationFrame(() => this.draw());\n    }\n    /**\n     * Draws the graph using dagre layouts\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    draw() {\n      if (!this.layout || typeof this.layout === 'string') {\n        return;\n      } // Calc view dims for the nodes\n\n\n      this.applyNodeDimensions(); // Recalc the layout\n\n      const result = this.layout.run(this.graph);\n      const result$ = result instanceof Observable ? result : of(result);\n      this.graphSubscription.add(result$.subscribe(graph => {\n        this.graph = graph;\n        this.tick();\n      }));\n\n      if (this.graph.nodes.length === 0) {\n        return;\n      }\n\n      result$.pipe(first()).subscribe(() => this.applyNodeDimensions());\n    }\n\n    tick() {\n      // Transposes view options to the node\n      const oldNodes = new Set();\n      this.graph.nodes.map(n => {\n        n.transform = `translate(${n.position.x - n.dimension.width / 2 || 0}, ${n.position.y - n.dimension.height / 2 || 0})`;\n\n        if (!n.data) {\n          n.data = {};\n        }\n\n        n.data.color = this.colors.getColor(this.groupResultsBy(n));\n        oldNodes.add(n.id);\n      });\n      const oldClusters = new Set();\n      (this.graph.clusters || []).map(n => {\n        n.transform = `translate(${n.position.x - n.dimension.width / 2 || 0}, ${n.position.y - n.dimension.height / 2 || 0})`;\n\n        if (!n.data) {\n          n.data = {};\n        }\n\n        n.data.color = this.colors.getColor(this.groupResultsBy(n));\n        oldClusters.add(n.id);\n      }); // Prevent animations on new nodes\n\n      setTimeout(() => {\n        this.oldNodes = oldNodes;\n        this.oldClusters = oldClusters;\n      }, 500); // Update the labels to the new positions\n\n      const newLinks = [];\n\n      for (const edgeLabelId in this.graph.edgeLabels) {\n        const edgeLabel = this.graph.edgeLabels[edgeLabelId];\n        const normKey = edgeLabelId.replace(/[^\\w-]*/g, '');\n        const isMultigraph = this.layout && typeof this.layout !== 'string' && this.layout.settings && this.layout.settings.multigraph;\n        let oldLink = isMultigraph ? this._oldLinks.find(ol => `${ol.source}${ol.target}${ol.id}` === normKey) : this._oldLinks.find(ol => `${ol.source}${ol.target}` === normKey);\n        const linkFromGraph = isMultigraph ? this.graph.edges.find(nl => `${nl.source}${nl.target}${nl.id}` === normKey) : this.graph.edges.find(nl => `${nl.source}${nl.target}` === normKey);\n\n        if (!oldLink) {\n          oldLink = linkFromGraph || edgeLabel;\n        } else if (oldLink.data && linkFromGraph && linkFromGraph.data && JSON.stringify(oldLink.data) !== JSON.stringify(linkFromGraph.data)) {\n          // Compare old link to new link and replace if not equal\n          oldLink.data = linkFromGraph.data;\n        }\n\n        oldLink.oldLine = oldLink.line;\n        const points = edgeLabel.points;\n        const line = this.generateLine(points);\n        const newLink = Object.assign({}, oldLink);\n        newLink.line = line;\n        newLink.points = points;\n        this.updateMidpointOnEdge(newLink, points);\n        const textPos = points[Math.floor(points.length / 2)];\n\n        if (textPos) {\n          newLink.textTransform = `translate(${textPos.x || 0},${textPos.y || 0})`;\n        }\n\n        newLink.textAngle = 0;\n\n        if (!newLink.oldLine) {\n          newLink.oldLine = newLink.line;\n        }\n\n        this.calcDominantBaseline(newLink);\n        newLinks.push(newLink);\n      }\n\n      this.graph.edges = newLinks; // Map the old links for animations\n\n      if (this.graph.edges) {\n        this._oldLinks = this.graph.edges.map(l => {\n          const newL = Object.assign({}, l);\n          newL.oldLine = l.line;\n          return newL;\n        });\n      }\n\n      this.updateMinimap();\n\n      if (this.autoZoom) {\n        this.zoomToFit();\n      }\n\n      if (this.autoCenter) {\n        // Auto-center when rendering\n        this.center();\n      }\n\n      requestAnimationFrame(() => this.redrawLines());\n      this.cd.markForCheck();\n    }\n\n    getMinimapTransform() {\n      switch (this.miniMapPosition) {\n        case MiniMapPosition.UpperLeft:\n          {\n            return '';\n          }\n\n        case MiniMapPosition.UpperRight:\n          {\n            return 'translate(' + (this.dims.width - this.graphDims.width / this.minimapScaleCoefficient) + ',' + 0 + ')';\n          }\n\n        default:\n          {\n            return '';\n          }\n      }\n    }\n\n    updateGraphDims() {\n      let minX = +Infinity;\n      let maxX = -Infinity;\n      let minY = +Infinity;\n      let maxY = -Infinity;\n\n      for (let i = 0; i < this.graph.nodes.length; i++) {\n        const node = this.graph.nodes[i];\n        minX = node.position.x < minX ? node.position.x : minX;\n        minY = node.position.y < minY ? node.position.y : minY;\n        maxX = node.position.x + node.dimension.width > maxX ? node.position.x + node.dimension.width : maxX;\n        maxY = node.position.y + node.dimension.height > maxY ? node.position.y + node.dimension.height : maxY;\n      }\n\n      minX -= 100;\n      minY -= 100;\n      maxX += 100;\n      maxY += 100;\n      this.graphDims.width = maxX - minX;\n      this.graphDims.height = maxY - minY;\n      this.minimapOffsetX = minX;\n      this.minimapOffsetY = minY;\n    }\n\n    updateMinimap() {\n      // Calculate the height/width total, but only if we have any nodes\n      if (this.graph.nodes && this.graph.nodes.length) {\n        this.updateGraphDims();\n\n        if (this.miniMapMaxWidth) {\n          this.minimapScaleCoefficient = this.graphDims.width / this.miniMapMaxWidth;\n        }\n\n        if (this.miniMapMaxHeight) {\n          this.minimapScaleCoefficient = Math.max(this.minimapScaleCoefficient, this.graphDims.height / this.miniMapMaxHeight);\n        }\n\n        this.minimapTransform = this.getMinimapTransform();\n      }\n    }\n    /**\n     * Measures the node element and applies the dimensions\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    applyNodeDimensions() {\n      if (this.nodeElements && this.nodeElements.length) {\n        this.nodeElements.map(elem => {\n          const nativeElement = elem.nativeElement;\n          const node = this.graph.nodes.find(n => n.id === nativeElement.id);\n\n          if (!node) {\n            return;\n          } // calculate the height\n\n\n          let dims;\n\n          try {\n            dims = nativeElement.getBBox();\n\n            if (!dims.width || !dims.height) {\n              return;\n            }\n          } catch (ex) {\n            // Skip drawing if element is not displayed - Firefox would throw an error here\n            return;\n          }\n\n          if (this.nodeHeight) {\n            node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : this.nodeHeight;\n          } else {\n            node.dimension.height = node.dimension.height && node.meta.forceDimensions ? node.dimension.height : dims.height;\n          }\n\n          if (this.nodeMaxHeight) {\n            node.dimension.height = Math.max(node.dimension.height, this.nodeMaxHeight);\n          }\n\n          if (this.nodeMinHeight) {\n            node.dimension.height = Math.min(node.dimension.height, this.nodeMinHeight);\n          }\n\n          if (this.nodeWidth) {\n            node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : this.nodeWidth;\n          } else {\n            // calculate the width\n            if (nativeElement.getElementsByTagName('text').length) {\n              let maxTextDims;\n\n              try {\n                for (const textElem of nativeElement.getElementsByTagName('text')) {\n                  const currentBBox = textElem.getBBox();\n\n                  if (!maxTextDims) {\n                    maxTextDims = currentBBox;\n                  } else {\n                    if (currentBBox.width > maxTextDims.width) {\n                      maxTextDims.width = currentBBox.width;\n                    }\n\n                    if (currentBBox.height > maxTextDims.height) {\n                      maxTextDims.height = currentBBox.height;\n                    }\n                  }\n                }\n              } catch (ex) {\n                // Skip drawing if element is not displayed - Firefox would throw an error here\n                return;\n              }\n\n              node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : maxTextDims.width + 20;\n            } else {\n              node.dimension.width = node.dimension.width && node.meta.forceDimensions ? node.dimension.width : dims.width;\n            }\n          }\n\n          if (this.nodeMaxWidth) {\n            node.dimension.width = Math.max(node.dimension.width, this.nodeMaxWidth);\n          }\n\n          if (this.nodeMinWidth) {\n            node.dimension.width = Math.min(node.dimension.width, this.nodeMinWidth);\n          }\n        });\n      }\n    }\n    /**\n     * Redraws the lines when dragged or viewport updated\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    redrawLines(_animate = this.animate) {\n      this.linkElements.map(linkEl => {\n        const edge = this.graph.edges.find(lin => lin.id === linkEl.nativeElement.id);\n\n        if (edge) {\n          const linkSelection = select(linkEl.nativeElement).select('.line');\n          linkSelection.attr('d', edge.oldLine).transition().ease(easeSinInOut).duration(_animate ? 500 : 0).attr('d', edge.line);\n          const textPathSelection = select(this.chartElement.nativeElement).select(`#${edge.id}`);\n          textPathSelection.attr('d', edge.oldTextPath).transition().ease(easeSinInOut).duration(_animate ? 500 : 0).attr('d', edge.textPath);\n          this.updateMidpointOnEdge(edge, edge.points);\n        }\n      });\n    }\n    /**\n     * Calculate the text directions / flipping\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    calcDominantBaseline(link) {\n      const firstPoint = link.points[0];\n      const lastPoint = link.points[link.points.length - 1];\n      link.oldTextPath = link.textPath;\n\n      if (lastPoint.x < firstPoint.x) {\n        link.dominantBaseline = 'text-before-edge'; // reverse text path for when its flipped upside down\n\n        link.textPath = this.generateLine([...link.points].reverse());\n      } else {\n        link.dominantBaseline = 'text-after-edge';\n        link.textPath = link.line;\n      }\n    }\n    /**\n     * Generate the new line path\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    generateLine(points) {\n      const lineFunction = line().x(d => d.x).y(d => d.y).curve(this.curve);\n      return lineFunction(points);\n    }\n    /**\n     * Zoom was invoked from event\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onZoom($event, direction) {\n      if (this.enableTrackpadSupport && !$event.ctrlKey) {\n        this.pan($event.deltaX * -1, $event.deltaY * -1);\n        return;\n      }\n\n      const zoomFactor = 1 + (direction === 'in' ? this.zoomSpeed : -this.zoomSpeed); // Check that zooming wouldn't put us out of bounds\n\n      const newZoomLevel = this.zoomLevel * zoomFactor;\n\n      if (newZoomLevel <= this.minZoomLevel || newZoomLevel >= this.maxZoomLevel) {\n        return;\n      } // Check if zooming is enabled or not\n\n\n      if (!this.enableZoom) {\n        return;\n      }\n\n      if (this.panOnZoom === true && $event) {\n        // Absolute mouse X/Y on the screen\n        const mouseX = $event.clientX;\n        const mouseY = $event.clientY; // Transform the mouse X/Y into a SVG X/Y\n\n        const svg = this.chart.nativeElement.querySelector('svg');\n        const svgGroup = svg.querySelector('g.chart');\n        const point = svg.createSVGPoint();\n        point.x = mouseX;\n        point.y = mouseY;\n        const svgPoint = point.matrixTransform(svgGroup.getScreenCTM().inverse()); // Panzoom\n\n        this.pan(svgPoint.x, svgPoint.y, true);\n        this.zoom(zoomFactor);\n        this.pan(-svgPoint.x, -svgPoint.y, true);\n      } else {\n        this.zoom(zoomFactor);\n      }\n    }\n    /**\n     * Pan by x/y\n     *\n     * @param x\n     * @param y\n     */\n\n\n    pan(x, y, ignoreZoomLevel = false) {\n      const zoomLevel = ignoreZoomLevel ? 1 : this.zoomLevel;\n      this.transformationMatrix = transform(this.transformationMatrix, translate(x / zoomLevel, y / zoomLevel));\n      this.updateTransform();\n    }\n    /**\n     * Pan to a fixed x/y\n     *\n     */\n\n\n    panTo(x, y) {\n      if (x === null || x === undefined || isNaN(x) || y === null || y === undefined || isNaN(y)) {\n        return;\n      }\n\n      const panX = -this.panOffsetX - x * this.zoomLevel + this.dims.width / 2;\n      const panY = -this.panOffsetY - y * this.zoomLevel + this.dims.height / 2;\n      this.transformationMatrix = transform(this.transformationMatrix, translate(panX / this.zoomLevel, panY / this.zoomLevel));\n      this.updateTransform();\n    }\n    /**\n     * Zoom by a factor\n     *\n     */\n\n\n    zoom(factor) {\n      this.transformationMatrix = transform(this.transformationMatrix, scale(factor, factor));\n      this.zoomChange.emit(this.zoomLevel);\n      this.updateTransform();\n    }\n    /**\n     * Zoom to a fixed level\n     *\n     */\n\n\n    zoomTo(level) {\n      this.transformationMatrix.a = isNaN(level) ? this.transformationMatrix.a : Number(level);\n      this.transformationMatrix.d = isNaN(level) ? this.transformationMatrix.d : Number(level);\n      this.zoomChange.emit(this.zoomLevel);\n      this.updateTransform();\n      this.update();\n    }\n    /**\n     * Drag was invoked from an event\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onDrag(event) {\n      if (!this.draggingEnabled) {\n        return;\n      }\n\n      const node = this.draggingNode;\n\n      if (this.layout && typeof this.layout !== 'string' && this.layout.onDrag) {\n        this.layout.onDrag(node, event);\n      }\n\n      node.position.x += event.movementX / this.zoomLevel;\n      node.position.y += event.movementY / this.zoomLevel; // move the node\n\n      const x = node.position.x - node.dimension.width / 2;\n      const y = node.position.y - node.dimension.height / 2;\n      node.transform = `translate(${x}, ${y})`;\n\n      for (const link of this.graph.edges) {\n        if (link.target === node.id || link.source === node.id || link.target.id === node.id || link.source.id === node.id) {\n          if (this.layout && typeof this.layout !== 'string') {\n            const result = this.layout.updateEdge(this.graph, link);\n            const result$ = result instanceof Observable ? result : of(result);\n            this.graphSubscription.add(result$.subscribe(graph => {\n              this.graph = graph;\n              this.redrawEdge(link);\n            }));\n          }\n        }\n      }\n\n      this.redrawLines(false);\n      this.updateMinimap();\n    }\n\n    redrawEdge(edge) {\n      const line = this.generateLine(edge.points);\n      this.calcDominantBaseline(edge);\n      edge.oldLine = edge.line;\n      edge.line = line;\n    }\n    /**\n     * Update the entire view for the new pan position\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    updateTransform() {\n      this.transform = toSVG(smoothMatrix(this.transformationMatrix, 100));\n    }\n    /**\n     * Node was clicked\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onClick(event) {\n      this.select.emit(event);\n    }\n    /**\n     * Node was focused\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onActivate(event) {\n      if (this.activeEntries.indexOf(event) > -1) {\n        return;\n      }\n\n      this.activeEntries = [event, ...this.activeEntries];\n      this.activate.emit({\n        value: event,\n        entries: this.activeEntries\n      });\n    }\n    /**\n     * Node was defocused\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onDeactivate(event) {\n      const idx = this.activeEntries.indexOf(event);\n      this.activeEntries.splice(idx, 1);\n      this.activeEntries = [...this.activeEntries];\n      this.deactivate.emit({\n        value: event,\n        entries: this.activeEntries\n      });\n    }\n    /**\n     * Get the domain series for the nodes\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    getSeriesDomain() {\n      return this.nodes.map(d => this.groupResultsBy(d)).reduce((nodes, node) => nodes.indexOf(node) !== -1 ? nodes : nodes.concat([node]), []).sort();\n    }\n    /**\n     * Tracking for the link\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    trackLinkBy(index, link) {\n      return link.id;\n    }\n    /**\n     * Tracking for the node\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    trackNodeBy(index, node) {\n      return node.id;\n    }\n    /**\n     * Sets the colors the nodes\n     *\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    setColors() {\n      this.colors = new ColorHelper(this.scheme, 'ordinal', this.seriesDomain, this.customColors);\n    }\n    /**\n     * Gets the legend options\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    getLegendOptions() {\n      return {\n        scaleType: 'ordinal',\n        domain: this.seriesDomain,\n        colors: this.colors\n      };\n    }\n    /**\n     * On mouse move event, used for panning and dragging.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMouseMove($event) {\n      this.isMouseMoveCalled = true;\n\n      if ((this.isPanning || this.isMinimapPanning) && this.panningEnabled) {\n        this.panWithConstraints(this.panningAxis, $event);\n      } else if (this.isDragging && this.draggingEnabled) {\n        this.onDrag($event);\n      }\n    }\n\n    onMouseDown(event) {\n      this.isMouseMoveCalled = false;\n    }\n\n    graphClick(event) {\n      if (!this.isMouseMoveCalled) this.clickHandler.emit(event);\n    }\n    /**\n     * On touch start event to enable panning.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onTouchStart(event) {\n      this._touchLastX = event.changedTouches[0].clientX;\n      this._touchLastY = event.changedTouches[0].clientY;\n      this.isPanning = true;\n    }\n    /**\n     * On touch move event, used for panning.\n     *\n     */\n\n\n    onTouchMove($event) {\n      if (this.isPanning && this.panningEnabled) {\n        const clientX = $event.changedTouches[0].clientX;\n        const clientY = $event.changedTouches[0].clientY;\n        const movementX = clientX - this._touchLastX;\n        const movementY = clientY - this._touchLastY;\n        this._touchLastX = clientX;\n        this._touchLastY = clientY;\n        this.pan(movementX, movementY);\n      }\n    }\n    /**\n     * On touch end event to disable panning.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onTouchEnd(event) {\n      this.isPanning = false;\n    }\n    /**\n     * On mouse up event to disable panning/dragging.\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMouseUp(event) {\n      this.isDragging = false;\n      this.isPanning = false;\n      this.isMinimapPanning = false;\n\n      if (this.layout && typeof this.layout !== 'string' && this.layout.onDragEnd) {\n        this.layout.onDragEnd(this.draggingNode, event);\n      }\n    }\n    /**\n     * On node mouse down to kick off dragging\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onNodeMouseDown(event, node) {\n      if (!this.draggingEnabled) {\n        return;\n      }\n\n      this.isDragging = true;\n      this.draggingNode = node;\n\n      if (this.layout && typeof this.layout !== 'string' && this.layout.onDragStart) {\n        this.layout.onDragStart(node, event);\n      }\n    }\n    /**\n     * On minimap drag mouse down to kick off minimap panning\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMinimapDragMouseDown() {\n      this.isMinimapPanning = true;\n    }\n    /**\n     * On minimap pan event. Pans the graph to the clicked position\n     *\n     * @memberOf GraphComponent\n     */\n\n\n    onMinimapPanTo(event) {\n      let x = event.offsetX - (this.dims.width - (this.graphDims.width + this.minimapOffsetX) / this.minimapScaleCoefficient);\n      let y = event.offsetY + this.minimapOffsetY / this.minimapScaleCoefficient;\n      this.panTo(x * this.minimapScaleCoefficient, y * this.minimapScaleCoefficient);\n      this.isMinimapPanning = true;\n    }\n    /**\n     * Center the graph in the viewport\n     */\n\n\n    center() {\n      this.panTo(this.graphDims.width / 2, this.graphDims.height / 2);\n    }\n    /**\n     * Zooms to fit the entier graph\n     */\n\n\n    zoomToFit() {\n      const heightZoom = this.dims.height / this.graphDims.height;\n      const widthZoom = this.dims.width / this.graphDims.width;\n      let zoomLevel = Math.min(heightZoom, widthZoom, 1);\n\n      if (zoomLevel < this.minZoomLevel) {\n        zoomLevel = this.minZoomLevel;\n      }\n\n      if (zoomLevel > this.maxZoomLevel) {\n        zoomLevel = this.maxZoomLevel;\n      }\n\n      if (zoomLevel !== this.zoomLevel) {\n        this.zoomLevel = zoomLevel;\n        this.updateTransform();\n        this.zoomChange.emit(this.zoomLevel);\n      }\n    }\n    /**\n     * Pans to the node\n     * @param nodeId\n     */\n\n\n    panToNodeId(nodeId) {\n      const node = this.graph.nodes.find(n => n.id === nodeId);\n\n      if (!node) {\n        return;\n      }\n\n      this.panTo(node.position.x, node.position.y);\n    }\n\n    panWithConstraints(key, event) {\n      let x = event.movementX;\n      let y = event.movementY;\n\n      if (this.isMinimapPanning) {\n        x = -this.minimapScaleCoefficient * x * this.zoomLevel;\n        y = -this.minimapScaleCoefficient * y * this.zoomLevel;\n      }\n\n      switch (key) {\n        case PanningAxis.Horizontal:\n          this.pan(x, 0);\n          break;\n\n        case PanningAxis.Vertical:\n          this.pan(0, y);\n          break;\n\n        default:\n          this.pan(x, y);\n          break;\n      }\n    }\n\n    updateMidpointOnEdge(edge, points) {\n      if (!edge || !points) {\n        return;\n      }\n\n      if (points.length % 2 === 1) {\n        edge.midPoint = points[Math.floor(points.length / 2)];\n      } else {\n        const _first = points[points.length / 2];\n        const _second = points[points.length / 2 - 1];\n        edge.midPoint = {\n          x: (_first.x + _second.x) / 2,\n          y: (_first.y + _second.y) / 2\n        };\n      }\n    }\n\n  }\n\n  GraphComponent.ɵfac = function GraphComponent_Factory(t) {\n    return new (t || GraphComponent)(ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ElementRef), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.NgZone), ɵngcc0.ɵɵdirectiveInject(ɵngcc0.ChangeDetectorRef), ɵngcc0.ɵɵdirectiveInject(LayoutService));\n  };\n\n  GraphComponent.ɵcmp = /*@__PURE__*/ɵngcc0.ɵɵdefineComponent({\n    type: GraphComponent,\n    selectors: [[\"ngx-graph\"]],\n    contentQueries: function GraphComponent_ContentQueries(rf, ctx, dirIndex) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c0, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c1, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c2, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c3, 5);\n        ɵngcc0.ɵɵcontentQuery(dirIndex, _c4, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linkTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.clusterTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.defsTemplate = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.miniMapNodeTemplate = _t.first);\n      }\n    },\n    viewQuery: function GraphComponent_Query(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵviewQuery(ChartComponent, 7, ElementRef);\n        ɵngcc0.ɵɵviewQuery(_c5, 5);\n        ɵngcc0.ɵɵviewQuery(_c6, 5);\n      }\n\n      if (rf & 2) {\n        let _t;\n\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.chart = _t.first);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.nodeElements = _t);\n        ɵngcc0.ɵɵqueryRefresh(_t = ɵngcc0.ɵɵloadQuery()) && (ctx.linkElements = _t);\n      }\n    },\n    hostBindings: function GraphComponent_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousemove\", function GraphComponent_mousemove_HostBindingHandler($event) {\n          return ctx.onMouseMove($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"mousedown\", function GraphComponent_mousedown_HostBindingHandler($event) {\n          return ctx.onMouseDown($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"click\", function GraphComponent_click_HostBindingHandler($event) {\n          return ctx.graphClick($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"touchmove\", function GraphComponent_touchmove_HostBindingHandler($event) {\n          return ctx.onTouchMove($event);\n        }, false, ɵngcc0.ɵɵresolveDocument)(\"mouseup\", function GraphComponent_mouseup_HostBindingHandler($event) {\n          return ctx.onMouseUp($event);\n        }, false, ɵngcc0.ɵɵresolveDocument);\n      }\n    },\n    inputs: {\n      legend: \"legend\",\n      nodes: \"nodes\",\n      clusters: \"clusters\",\n      links: \"links\",\n      activeEntries: \"activeEntries\",\n      draggingEnabled: \"draggingEnabled\",\n      panningEnabled: \"panningEnabled\",\n      panningAxis: \"panningAxis\",\n      enableZoom: \"enableZoom\",\n      zoomSpeed: \"zoomSpeed\",\n      minZoomLevel: \"minZoomLevel\",\n      maxZoomLevel: \"maxZoomLevel\",\n      autoZoom: \"autoZoom\",\n      panOnZoom: \"panOnZoom\",\n      animate: \"animate\",\n      autoCenter: \"autoCenter\",\n      enableTrackpadSupport: \"enableTrackpadSupport\",\n      showMiniMap: \"showMiniMap\",\n      miniMapMaxWidth: \"miniMapMaxWidth\",\n      miniMapPosition: \"miniMapPosition\",\n      groupResultsBy: \"groupResultsBy\",\n      zoomLevel: \"zoomLevel\",\n      panOffsetX: \"panOffsetX\",\n      panOffsetY: \"panOffsetY\",\n      layout: \"layout\",\n      curve: \"curve\",\n      nodeHeight: \"nodeHeight\",\n      nodeMaxHeight: \"nodeMaxHeight\",\n      nodeMinHeight: \"nodeMinHeight\",\n      nodeWidth: \"nodeWidth\",\n      nodeMinWidth: \"nodeMinWidth\",\n      nodeMaxWidth: \"nodeMaxWidth\",\n      update$: \"update$\",\n      center$: \"center$\",\n      zoomToFit$: \"zoomToFit$\",\n      panToNode$: \"panToNode$\",\n      layoutSettings: \"layoutSettings\",\n      miniMapMaxHeight: \"miniMapMaxHeight\"\n    },\n    outputs: {\n      activate: \"activate\",\n      deactivate: \"deactivate\",\n      zoomChange: \"zoomChange\",\n      clickHandler: \"clickHandler\"\n    },\n    features: [ɵngcc0.ɵɵInheritDefinitionFeature, ɵngcc0.ɵɵNgOnChangesFeature],\n    ngContentSelectors: _c9,\n    decls: 5,\n    vars: 11,\n    consts: [[\"mouseWheel\", \"\", 3, \"view\", \"showLegend\", \"legendOptions\", \"legendLabelClick\", \"legendLabelActivate\", \"legendLabelDeactivate\", \"mouseWheelUp\", \"mouseWheelDown\"], [\"class\", \"graph chart\", 3, \"touchstart\", \"touchend\", 4, \"ngIf\"], [\"class\", \"minimap\", 4, \"ngIf\"], [1, \"graph\", \"chart\", 3, \"touchstart\", \"touchend\"], [3, \"ngTemplateOutlet\", 4, \"ngIf\"], [\"class\", \"text-path\", 4, \"ngFor\", \"ngForOf\"], [1, \"panning-rect\", 3, \"mousedown\"], [1, \"clusters\"], [\"class\", \"node-group\", 3, \"old-node\", \"id\", \"click\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"links\"], [\"class\", \"link-group\", 3, \"id\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"nodes\"], [\"class\", \"node-group\", 3, \"old-node\", \"id\", \"click\", \"mousedown\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [3, \"ngTemplateOutlet\"], [1, \"text-path\"], [1, \"node-group\", 3, \"id\", \"click\"], [\"clusterElement\", \"\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\", 4, \"ngIf\"], [\"class\", \"node cluster\", 4, \"ngIf\"], [3, \"ngTemplateOutlet\", \"ngTemplateOutletContext\"], [1, \"node\", \"cluster\"], [\"alignment-baseline\", \"central\"], [1, \"link-group\", 3, \"id\"], [\"linkElement\", \"\"], [\"class\", \"edge\", 4, \"ngIf\"], [1, \"edge\"], [1, \"node-group\", 3, \"id\", \"click\", \"mousedown\"], [\"nodeElement\", \"\"], [\"r\", \"10\", 4, \"ngIf\"], [\"r\", \"10\"], [1, \"minimap\"], [1, \"minimap-background\", 3, \"mousedown\"], [1, \"minimap-nodes\"], [\"class\", \"node-group\", 3, \"old-node\", \"id\", 4, \"ngFor\", \"ngForOf\", \"ngForTrackBy\"], [1, \"minimap-drag\", 3, \"mousedown\"], [1, \"node-group\", 3, \"id\"]],\n    template: function GraphComponent_Template(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵprojectionDef();\n        ɵngcc0.ɵɵelementStart(0, \"ngx-charts-chart\", 0);\n        ɵngcc0.ɵɵlistener(\"legendLabelClick\", function GraphComponent_Template_ngx_charts_chart_legendLabelClick_0_listener($event) {\n          return ctx.onClick($event);\n        })(\"legendLabelActivate\", function GraphComponent_Template_ngx_charts_chart_legendLabelActivate_0_listener($event) {\n          return ctx.onActivate($event);\n        })(\"legendLabelDeactivate\", function GraphComponent_Template_ngx_charts_chart_legendLabelDeactivate_0_listener($event) {\n          return ctx.onDeactivate($event);\n        })(\"mouseWheelUp\", function GraphComponent_Template_ngx_charts_chart_mouseWheelUp_0_listener($event) {\n          return ctx.onZoom($event, \"in\");\n        })(\"mouseWheelDown\", function GraphComponent_Template_ngx_charts_chart_mouseWheelDown_0_listener($event) {\n          return ctx.onZoom($event, \"out\");\n        });\n        ɵngcc0.ɵɵtemplate(1, GraphComponent__svg_g_1_Template, 12, 12, \"g\", 1);\n        ɵngcc0.ɵɵnamespaceSVG();\n        ɵngcc0.ɵɵelementStart(2, \"clipPath\");\n        ɵngcc0.ɵɵelement(3, \"rect\");\n        ɵngcc0.ɵɵelementEnd();\n        ɵngcc0.ɵɵtemplate(4, GraphComponent__svg_g_4_Template, 6, 15, \"g\", 2);\n        ɵngcc0.ɵɵelementEnd();\n      }\n\n      if (rf & 2) {\n        ɵngcc0.ɵɵproperty(\"view\", ɵngcc0.ɵɵpureFunction2(8, _c8, ctx.width, ctx.height))(\"showLegend\", ctx.legend)(\"legendOptions\", ctx.legendOptions);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.initialized && ctx.graph);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵattribute(\"id\", ctx.minimapClipPathId);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵattribute(\"width\", ctx.graphDims.width / ctx.minimapScaleCoefficient)(\"height\", ctx.graphDims.height / ctx.minimapScaleCoefficient);\n        ɵngcc0.ɵɵadvance(1);\n        ɵngcc0.ɵɵproperty(\"ngIf\", ctx.showMiniMap);\n      }\n    },\n    directives: function () {\n      return [ɵngcc1.ChartComponent, MouseWheelDirective, ɵngcc2.NgIf, ɵngcc2.NgForOf, ɵngcc2.NgTemplateOutlet];\n    },\n    styles: [\".minimap .minimap-background{fill:rgba(0,0,0,.1)}.minimap .minimap-drag{cursor:pointer;fill:rgba(0,0,0,.2);stroke:#fff;stroke-dasharray:2px;stroke-dashoffset:2px;stroke-width:1px}.minimap .minimap-drag.panning{fill:rgba(0,0,0,.3)}.minimap .minimap-nodes{opacity:.5;pointer-events:none}.graph{-moz-user-select:none;-ms-user-select:none;-webkit-user-select:none;user-select:none}.graph .edge{fill:none;stroke:#666}.graph .edge .edge-label{fill:#251e1e;font-size:12px;stroke:none}.graph .panning-rect{cursor:move;fill:transparent}.graph .node-group.old-node{transition:transform .5s ease-in-out}.graph .node-group .node:focus{outline:none}.graph .cluster rect{opacity:.2}\"],\n    encapsulation: 2,\n    changeDetection: 0\n  });\n\n  __decorate([throttleable(500), __metadata(\"design:type\", Function), __metadata(\"design:paramtypes\", []), __metadata(\"design:returntype\", void 0)], GraphComponent.prototype, \"updateMinimap\", null);\n\n  return GraphComponent;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n/**\n * Mousewheel directive\n * https://github.com/SodhanaLibrary/angular2-examples/blob/master/app/mouseWheelDirective/mousewheel.directive.ts\n *\n * @export\n */\n// tslint:disable-next-line: directive-selector\n\n\nlet MouseWheelDirective = /*#__PURE__*/(() => {\n  class MouseWheelDirective {\n    constructor() {\n      this.mouseWheelUp = new EventEmitter();\n      this.mouseWheelDown = new EventEmitter();\n    }\n\n    onMouseWheelChrome(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    onMouseWheelFirefox(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    onWheel(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    onMouseWheelIE(event) {\n      this.mouseWheelFunc(event);\n    }\n\n    mouseWheelFunc(event) {\n      if (window.event) {\n        event = window.event;\n      }\n\n      const delta = Math.max(-1, Math.min(1, event.wheelDelta || -event.detail || event.deltaY || event.deltaX)); // Firefox don't have native support for wheel event, as a result delta values are reverse\n\n      const isWheelMouseUp = event.wheelDelta ? delta > 0 : delta < 0;\n      const isWheelMouseDown = event.wheelDelta ? delta < 0 : delta > 0;\n\n      if (isWheelMouseUp) {\n        this.mouseWheelUp.emit(event);\n      } else if (isWheelMouseDown) {\n        this.mouseWheelDown.emit(event);\n      } // for IE\n\n\n      event.returnValue = false; // for Chrome and Firefox\n\n      if (event.preventDefault) {\n        event.preventDefault();\n      }\n    }\n\n  }\n\n  MouseWheelDirective.ɵfac = function MouseWheelDirective_Factory(t) {\n    return new (t || MouseWheelDirective)();\n  };\n\n  MouseWheelDirective.ɵdir = /*@__PURE__*/ɵngcc0.ɵɵdefineDirective({\n    type: MouseWheelDirective,\n    selectors: [[\"\", \"mouseWheel\", \"\"]],\n    hostBindings: function MouseWheelDirective_HostBindings(rf, ctx) {\n      if (rf & 1) {\n        ɵngcc0.ɵɵlistener(\"mousewheel\", function MouseWheelDirective_mousewheel_HostBindingHandler($event) {\n          return ctx.onMouseWheelChrome($event);\n        })(\"DOMMouseScroll\", function MouseWheelDirective_DOMMouseScroll_HostBindingHandler($event) {\n          return ctx.onMouseWheelFirefox($event);\n        })(\"wheel\", function MouseWheelDirective_wheel_HostBindingHandler($event) {\n          return ctx.onWheel($event);\n        })(\"onmousewheel\", function MouseWheelDirective_onmousewheel_HostBindingHandler($event) {\n          return ctx.onMouseWheelIE($event);\n        });\n      }\n    },\n    outputs: {\n      mouseWheelUp: \"mouseWheelUp\",\n      mouseWheelDown: \"mouseWheelDown\"\n    }\n  });\n  return MouseWheelDirective;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\nlet GraphModule = /*#__PURE__*/(() => {\n  class GraphModule {}\n\n  GraphModule.ɵfac = function GraphModule_Factory(t) {\n    return new (t || GraphModule)();\n  };\n\n  GraphModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: GraphModule\n  });\n  GraphModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    providers: [LayoutService],\n    imports: [[ChartCommonModule]]\n  });\n  return GraphModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(GraphModule, {\n    declarations: function () {\n      return [GraphComponent, MouseWheelDirective];\n    },\n    imports: function () {\n      return [ChartCommonModule];\n    },\n    exports: function () {\n      return [GraphComponent, MouseWheelDirective];\n    }\n  });\n})();\n\nlet NgxGraphModule = /*#__PURE__*/(() => {\n  class NgxGraphModule {}\n\n  NgxGraphModule.ɵfac = function NgxGraphModule_Factory(t) {\n    return new (t || NgxGraphModule)();\n  };\n\n  NgxGraphModule.ɵmod = /*@__PURE__*/ɵngcc0.ɵɵdefineNgModule({\n    type: NgxGraphModule\n  });\n  NgxGraphModule.ɵinj = /*@__PURE__*/ɵngcc0.ɵɵdefineInjector({\n    imports: [[NgxChartsModule], GraphModule]\n  });\n  return NgxGraphModule;\n})();\n\n(function () {\n  (typeof ngDevMode === \"undefined\" || ngDevMode) && void 0;\n})();\n\n(function () {\n  (typeof ngJitMode === \"undefined\" || ngJitMode) && ɵngcc0.ɵɵsetNgModuleScope(NgxGraphModule, {\n    imports: function () {\n      return [NgxChartsModule];\n    },\n    exports: function () {\n      return [GraphModule];\n    }\n  });\n})();\n/*\n * Public API Surface of ngx-graph\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\n\nexport { Alignment, ColaForceDirectedLayout, D3ForceDirectedLayout, DagreClusterLayout, DagreLayout, DagreNodesOnlyLayout, GraphComponent, GraphModule, MiniMapPosition, MouseWheelDirective, NgxGraphModule, Orientation, PanningAxis, toD3Node, toNode, LayoutService as ɵa, throttleable as ɵb }; //# sourceMappingURL=swimlane-ngx-graph.js.map","map":null,"metadata":{},"sourceType":"module"}